/**
 * solution v0.1.0 build Feb 02 2016
 * https://github.com/vanruesc/solution
 * Copyright 2016 Raoul van RÃ¼schen, Zlib
 */
!function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],b):b(a.SOLUTION={},a.THREE)}(this,function(a,b){"use strict";function c(a){void 0===a&&(a={}),b.ShaderMaterial.call(this,{uniforms:{fogDensity:{type:"f",value:25e-5},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2e3},fogColor:{type:"c",value:new b.Color(16777215)},time:{type:"f",value:0},waterLevel:{type:"f",value:0},reflectionMap:{type:"t",value:null},refractionMap:{type:"t",value:null},normalMap:{type:"t",value:a.normalMap},offsetRepeat:{type:"v4",value:new b.Vector4(0,0,1,1)},waveScale:{type:"f",value:350},waveChoppiness:{type:"f",value:.01},bigWaves:{type:"v2",value:new b.Vector2(2,3)},midWaves:{type:"v2",value:new b.Vector2(4,2)},smallWaves:{type:"v2",value:new b.Vector2(1,.5)},windSpeed:{type:"f",value:.3},windDirection:{type:"v2",value:new b.Vector2(.2,-.5)},lightPosition:{type:"v3",value:a.lightPosition},waterDensity:{type:"f",value:1},chromaticAberration:{type:"f",value:.002},waterBump:{type:"f",value:1},reflectionBump:{type:"f",value:.1},refractionBump:{type:"f",value:.1},eta:{type:"f",value:1.33},waterColor:{type:"c",value:new b.Color(.2,.4,.5)},sunSpecular:{type:"f",value:250},scatterAmount:{type:"f",value:3},scatterColor:{type:"c",value:new b.Color(0,1,.95)},fade:{type:"f",value:12},luminosity:{type:"v3",value:new b.Vector3(.16,.32,.11)}},fragmentShader:a.lowQuality?r.fragment.low:r.fragment.high,vertexShader:r.vertex,side:b.DoubleSide,fog:!0})}function d(a){void 0===a&&(a={}),b.ShaderMaterial.call(this,{uniforms:{fogDensity:{type:"f",value:25e-5},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2e3},fogColor:{type:"c",value:new b.Color(16777215)},time:{type:"f",value:0},timeScale:{type:"f",value:void 0!==a.timeScale?a.timeScale:1},smoothness:{type:"f",value:void 0!==a.smoothness?a.smoothness:1e-4},fallAccel:{type:"f",value:void 0!==a.fallAccel?a.fallAccel:1.25},spread:{type:"f",value:void 0!==a.spread?a.spread:.6},drops:{type:"f",value:void 0!==a.drops?a.drops:16},shape:{type:"f",value:void 0!==a.shape?a.shape:1.2},power:{type:"f",value:void 0!==a.power?a.power:.7},alpha:{type:"f",value:void 0!==a.alpha?a.alpha:10},height:{type:"f",value:void 0!==a.height?a.height:.8},overflow:{type:"f",value:void 0!==a.overflow?a.overflow:.2},scale:{type:"v2",value:void 0!==a.scale?a.scale:new b.Vector2(1,1)},strength:{type:"v2",value:void 0!==a.strength?a.strength:new b.Vector2(6,26)},tint:{type:"c",value:void 0!==a.tint?a.tint:new b.Color(.25,.5,.5)},offsetRepeat:{type:"v4",value:new b.Vector4(-.5,-.75,1,1)}},fragmentShader:s.fragment,vertexShader:s.vertex,side:b.DoubleSide,transparent:!0,fog:!0})}function e(a,c){void 0===c&&(c={}),b.ShaderMaterial.call(this,{uniforms:{fogDensity:{type:"f",value:25e-5},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2e3},fogColor:{type:"c",value:new b.Color(16777215)},time:{type:"f",value:0},timeScale:{type:"f",value:void 0!==c.timeScale?c.timeScale:.1},primarySpeed:{type:"f",value:void 0!==c.primarySpeed?c.primarySpeed:.6},secondarySpeed:{type:"f",value:void 0!==c.secondarySpeed?c.secondarySpeed:1.9},displacement:{type:"f",value:void 0!==c.displacement?c.displacement:1},advection:{type:"f",value:void 0!==c.advection?c.advection:.77},intensity:{type:"f",value:void 0!==c.intensity?c.intensity:1.4},octaveScale:{type:"v2",value:void 0!==c.octaveScale?c.octaveScale:new b.Vector2(2,1.9)},lavaColor:{type:"c",value:void 0!==c.color?c.color:new b.Color(.2,.07,.01)},noiseMap:{type:"t",value:a},offsetRepeat:{type:"v4",value:new b.Vector4(0,0,3,3)}},fragmentShader:t.fragment,vertexShader:t.vertex,fog:!0})}function f(a){void 0===a&&(a={});var c=a.perturbMap,d=a.rollOffSpeed,e=a.waveStrength,f=a.color;b.ShaderMaterial.call(this,{defines:{T_DISSOLVE:"4.0",T_DROPLETS:"60.0"},uniforms:{tPerturb:{type:"t",value:void 0!==c?c:null},tDiffuse:{type:"t",value:null},time:{type:"f",value:1e3*Math.random()},resetTimer:{type:"f",value:0},rollOffSpeed:{type:"v2",value:void 0!==d?d:new b.Vector2(.5,.02)},waveStrength:{type:"v2",value:void 0!==e?e:new b.Vector2(.25,.5)},tint:{type:"c",value:void 0!==f?f:new b.Color(1,1,1)}},fragmentShader:u.fragment,vertexShader:u.vertex,extensions:{derivatives:!0}})}function g(a){b.ShaderMaterial.call(this,{uniforms:{tWidth:{type:"f",value:0},tHeight:{type:"f",value:0},time:{type:"f",value:0},randomTime:{type:"f",value:10*Math.random()-1}},fragmentShader:v.fragment,vertexShader:v.vertex}),a&&(this.defines.HIGH_QUALITY="1")}function h(){b.ShaderMaterial.call(this,{uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},fragmentShader:w.fragment,vertexShader:w.vertex})}function i(a,c){b.ShaderMaterial.call(this,{uniforms:{texture1:{type:"t",value:null},texture2:{type:"t",value:null},opacity1:{type:"f",value:1},opacity2:{type:"f",value:1}},fragmentShader:x.fragment,vertexShader:x.vertex}),a&&(this.defines.INVERT_TEX1="1"),c&&(this.defines.INVERT_TEX2="1")}function j(a,b){return Math.exp(-(a*a)/(2*b*b))}function k(){b.ShaderMaterial.call(this,{defines:{KERNEL_SIZE_FLOAT:"25.0",KERNEL_SIZE_INT:"25"},uniforms:{tDiffuse:{type:"t",value:null},uImageIncrement:{type:"v2",value:new b.Vector2(.001953125,0)},cKernel:{type:"fv1",value:[]}},fragmentShader:y.fragment,vertexShader:y.vertex})}function l(){b.ShaderMaterial.call(this,{defines:{NUM_SAMPLES_FLOAT:"6.0",NUM_SAMPLES_INT:"6"},uniforms:{tDiffuse:{type:"t",value:null},stepSize:{type:"f",value:1.5},decay:{type:"f",value:1},weight:{type:"f",value:1},exposure:{type:"f",value:1},lightPosition:{type:"v3",value:null}},fragmentShader:z.fragment,vertexShader:z.vertex})}function m(a,c,d){this.scene=void 0!==a?a:new b.Scene,this.camera=void 0!==c?c:new b.OrthographicCamera(-1,1,1,-1,0,1),this.quad=void 0!==d?d:new b.Mesh(new b.PlaneBufferGeometry(2,2),null),this.enabled=!0,this.renderToScreen=!1,this.needsSwap=!1,null!==this.scene&&(null!==this.camera&&null===this.camera.parent&&this.scene.add(this.camera),null!==this.quad&&this.scene.add(this.quad))}function n(a){m.call(this),void 0===a&&(a={}),void 0===a.kernelSize&&(a.kernelSize=25),this.renderTargetX=new b.WebGLRenderTarget(1,1,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat}),this.renderTargetX.texture.generateMipmaps=!1,this.renderTargetY=this.renderTargetX.clone(),this.renderTargetY.stencilBuffer=!1,this.renderTargetY.depthBuffer=!1,this.resolution=void 0===a.resolution?256:a.resolution,this.blurX=new b.Vector2(A,0),this.blurY=new b.Vector2(0,A),this.combineMaterial=new i,void 0!==a.strength&&(this.combineMaterial.uniforms.opacity2.value=a.strength),this.copyMaterial=new h,this.copyMaterial.blending=b.AdditiveBlending,this.copyMaterial.transparent=!0,void 0!==a.strength&&(this.copyMaterial.uniforms.opacity.value=a.strength),this.convolutionMaterial=new k,this.convolutionMaterial.buildKernel(void 0!==a.sigma?a.sigma:4),this.convolutionMaterial.defines.KERNEL_SIZE_FLOAT=a.kernelSize.toFixed(1),this.convolutionMaterial.defines.KERNEL_SIZE_INT=a.kernelSize.toFixed(0),this.clear=!1}function o(a,c,d,e){m.call(this),void 0===e&&(e={}),this.renderTargetX=new b.WebGLRenderTarget(1,1,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat}),this.renderTargetX.texture.generateMipmaps=!1,this.renderTargetY=this.renderTargetX.clone(),this.renderTargetY.stencilBuffer=!1,this.renderTargetY.depthBuffer=!1,this.resolution=void 0===e.resolution?512:e.resolution,this.lightSource=void 0!==d?d:new b.Object3D,this.screenLightPosition=new b.Vector3,this.godRaysMaterial=new l,this.godRaysMaterial.uniforms.lightPosition.value=this.screenLightPosition,void 0!==e.decay&&(this.godRaysMaterial.uniforms.decay.value=e.decay),void 0!==e.weight&&(this.godRaysMaterial.uniforms.weight.value=e.weight),void 0!==e.exposure&&(this.godRaysMaterial.uniforms.exposure.value=e.exposure),this.exposure=this.godRaysMaterial.uniforms.exposure.value,this.combineMaterial=new i,void 0!==e.intensity&&(this.combineMaterial.uniforms.opacity2.value=e.intensity),this.maskMaterial=new b.MeshBasicMaterial({color:0}),this._rayLength=void 0!==e.rayLength?e.rayLength:1,this.stepSizes=new Float32Array(3),this.samples=e.samples,this.mainScene=void 0!==a?a:new b.Scene,this.mainCamera=void 0!==c?c:new b.PerspectiveCamera,this.needsSwap=!0}function p(a,d,e,f){m.call(this,a,d,null),void 0===f&&(f={});var g=void 0===f.resolution?256:f.resolution;void 0===f.renderTarget&&(f.renderTarget=new b.WebGLRenderTarget(g,g,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat,stencilBuffer:!1,depthBuffer:!1})),this.reflectionTexture=f.renderTarget,this.refractionTexture=this.reflectionTexture.clone(),this.reflectionCamera=this.camera.clone(),this.refractionCamera=this.reflectionCamera.clone(),this.renderReflection=f.reflection,this.renderRefraction=f.refraction,this.material=f.disableWater?null:new c({lightPosition:e,normalMap:f.normalMap,lowQuality:f.lowQuality}),this.material.uniforms.reflectionMap.value=this.reflectionTexture,this.material.uniforms.refractionMap.value=this.refractionTexture;var h=new b.PlaneBufferGeometry(1,1),i=new Float32Array(16);i[0]=1,i[1]=0,i[2]=0,i[3]=-1,i[4]=1,i[5]=0,i[6]=0,i[7]=-1,i[8]=1,i[9]=0,i[10]=0,i[11]=-1,i[12]=1,i[13]=0,i[14]=0,i[15]=-1,h.addAttribute("tangent",new b.BufferAttribute(i,4)),this.mesh=new b.Mesh(h,this.material),this.mesh.matrixNeedsUpdate=!0,this.scene.add(this.mesh),this.textureMatrix=new b.Matrix4,this.plane=new b.Plane,this.normal=new b.Vector3(0,0,1),this.worldPosition=new b.Vector3,this.cameraWorldPosition=new b.Vector3,this.rotationMatrix=new b.Matrix4,this.lookAtPosition=new b.Vector3(0,0,-1),this.clipPlane=new b.Vector4,this.clipBias=void 0!==f.clipBias?f.clipBias:.2,this.update()}function q(a){m.call(this),void 0===a&&(a={}),this.renderTargetPerturb=new b.WebGLRenderTarget(1,1,{minFilter:b.LinearFilter,magFilter:b.LinearFilter,format:b.RGBFormat,type:b.FloatType,stencilBuffer:!1,depthBuffer:!1}),this.renderTargetPerturb.texture.generateMipmaps=!1,this.resolutionScale=void 0===a.resolution?1:b.Math.clamp(a.resolution,0,1),this.noiseMaterial=new g(a.highQuality),this.distortionMaterial=new f({perturbMap:this.renderTargetPerturb,rollOffSpeed:a.rollOffSpeed,waveStrength:a.waveStrength,tint:a.color}),this.speed=void 0===a.speed?1:a.speed,this.dissolutionEnd=Number.parseFloat(this.distortionMaterial.defines.T_DROPLETS),this._dissolve=!1,this.quad.material=this.distortionMaterial}b="default"in b?b["default"]:b;var r={fragment:{high:"#ifdef USE_FOG\n\n	#define LOG2 1.442695\n	#define saturate(a) clamp(a, 0.0, 1.0)\n	#define whiteCompliment(a) (1.0 - saturate(a))\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n\n	#endif\n\n#endif\n\n#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n\nuniform float time;\nuniform float waterLevel;\n\nuniform sampler2D reflectionMap;\nuniform sampler2D refractionMap;\nuniform sampler2D normalMap;\n\nuniform float waveScale;\nuniform vec2 bigWaves;\nuniform vec2 midWaves;\nuniform vec2 smallWaves;\nuniform float waveChoppiness;\n\nuniform float windSpeed;\nuniform vec2 windDirection;\n\nuniform float waterDensity;\nuniform float chromaticAberration;\nuniform float waterBump;\nuniform float reflectionBump;\nuniform float refractionBump;\nuniform float eta;\n\nuniform vec3 waterColor;\nuniform float sunSpecular;\nuniform float scatterAmount;\nuniform vec3 scatterColor;\n\nuniform float fade;\nuniform vec3 luminosity;\n\nvarying vec3 vLightDirection;\nvarying vec3 vViewPosition;\nvarying vec4 vFragPosition;\nvarying mat3 vTbn;\nvarying vec2 vUv;\n\nvec3 tangentSpace(vec3 v) {\n\n	//v.y = -v.y;\n	vec3 vec;\n	vec.xy = v.xy;\n	vec.z = sqrt(1.0 - dot(vec.xy, vec.xy));\n	vec.xyz = normalize(vec.x * vTbn[0] + vec.y * vTbn[1] + vec.z * vTbn[2]);\n\n	return vec;\n\n}\n\n/**\n * Computes fresnel reflectance without explicitly computing the refracted direction.\n */\n\nfloat fresnelDielectric(vec3 viewDirection, vec3 normal, float eta) {\n\n	float c = abs(dot(viewDirection, normal));\n	float g = eta * eta - 1.0 + c * c;\n	float A, B;\n	float result = 1.0;\n\n	if(g > 0.0)	{\n\n		g = sqrt(g);\n		A = (g - c) / (g + c);\n		B = (c * (g + c) - 1.0) / (c * (g - c) + 1.0);\n		result = 0.5 * A * A * (1.0 + B * B);\n\n	}\n\n	return result;\n\n}\n\nvoid main() {\n\n	vec2 fragCoord = (vFragPosition.xy / vFragPosition.w) * 0.5 + 0.5;\n	fragCoord = clamp(fragCoord, 0.002, 0.998);\n\n	// Normal map sampling.\n\n	vec2 nCoord = vec2(0.0);\n	vec2 offset = windDirection * time * windSpeed;\n\n	vec2 t[3];\n	t[0] = vec2(time * 0.005, time * 0.01);\n	t[1] = vec2(time * 0.02, time * 0.03);\n	t[2] = vec2(time * 0.06, time * 0.08);\n\n	nCoord = vUv * (waveScale * 0.015) + offset * 0.03;\n	vec3 normal0 = 2.0 * texture2D(normalMap, nCoord + vec2(-t[0][0], -t[0][1])).rgb - 1.0;\n	nCoord = vUv * (waveScale * 0.05) + offset * 0.05 - normal0.xy * waveChoppiness;\n	vec3 normal1 = 2.0 * texture2D(normalMap, nCoord + vec2(t[0][1], t[0][0])).rgb - 1.0;\n \n	nCoord = vUv * (waveScale * 0.15) + offset * 0.1 - normal1.xy * waveChoppiness;\n	vec3 normal2 = 2.0 * texture2D(normalMap, nCoord + vec2(-t[1][0], -t[1][1])).rgb - 1.0;\n	nCoord = vUv * (waveScale * 0.5) + offset * 0.2 - normal2.xy * waveChoppiness;\n	vec3 normal3 = 2.0 * texture2D(normalMap, nCoord + vec2(t[1][1], t[1][0])).rgb - 1.0;\n  \n	nCoord = vUv * (waveScale* 1.5) + offset * 1.0 - normal3.xy * waveChoppiness;\n	vec3 normal4 = 2.0 * texture2D(normalMap, nCoord + vec2(-t[2][0], t[2][1])).rgb - 1.0;  \n	nCoord = vUv * (waveScale * 5.0) + offset * 1.3 - normal4.xy * waveChoppiness;\n	vec3 normal5 = 2.0 * texture2D(normalMap, nCoord + vec2(t[2][1], -t[2][0])).rgb - 1.0;\n\n	vec3 viewDirection = normalize(vViewPosition);\n\n	vec3 waveNormal = normalize(\n		normal0 * bigWaves.x + normal1 * bigWaves.y +\n		normal2 * midWaves.x + normal3 * midWaves.y +\n		normal4 * smallWaves.x + normal5 * smallWaves.y\n	);\n\n	waveNormal = tangentSpace(waveNormal * waterBump);\n\n	vec3 scatterNormal = normalize(\n		normal0 * bigWaves.x + normal1 * bigWaves.y * 0.5 +\n		normal2 * midWaves.x * 0.3 + normal3 * midWaves.y * 0.3 +\n		normal4 * smallWaves.x * 0.2 + normal5 * smallWaves.y * 0.2\n	);\n\n	scatterNormal = tangentSpace(scatterNormal * waterBump);\n\n	vec3 lR = reflect(vLightDirection, scatterNormal);\n	float s = max(dot(lR, viewDirection) * 2.0 - 1.2, 0.0);\n	float lightScatter = clamp((max(dot(-vLightDirection, scatterNormal) * 0.75 + 0.25, 0.0) * s) * scatterAmount, 0.0, 1.0);\n\n	// Fresnel term.\n	float ior = (cameraPosition.y > waterLevel) ? eta : 1.0 / eta;\n	float fresnel = fresnelDielectric(-viewDirection, waveNormal, ior);\n\n	// Texture edge bleed removal.\n	vec2 distortFade = vec2(0.0);\n	distortFade.s = clamp(fragCoord.s * fade, 0.0, 1.0);\n	distortFade.s -= clamp(1.0 - (1.0 - fragCoord.s) * fade, 0.0, 1.0);\n	distortFade.t = clamp(fragCoord.t * fade, 0.0, 1.0);\n	distortFade.t -= clamp(1.0 - (1.0 - fragCoord.t) * fade, 0.0, 1.0);\n\n	// Inverting frag coord s, because reflection sampler is mirrored along x axis.\n	vec3 reflection = texture2D(reflectionMap, vec2(1.0 - fragCoord.s, fragCoord.t) + (waveNormal.xy * reflectionBump * distortFade)).rgb;\n\n	float reflectivity = pow(dot(luminosity, reflection.rgb * 2.0), 3.0);\n\n	vec3 R = reflect(viewDirection, waveNormal);\n\n	float specular = pow(max(dot(R, vLightDirection), 0.0), sunSpecular) * reflectivity;\n\n	vec2 rCoord = reflect(viewDirection, waveNormal).st;\n	rCoord *= chromaticAberration;\n\n	vec2 fCoord = fragCoord - (waveNormal.xy * refractionBump * distortFade);\n\n	vec3 refraction = vec3(0.0);\n	refraction.r = texture2D(refractionMap, fCoord).r;\n	refraction.g = texture2D(refractionMap, fCoord - rCoord).g;\n	refraction.b = texture2D(refractionMap, fCoord - rCoord * 2.0).b;\n\n	vec3 transmittance = mix(refraction, refraction * waterColor, waterDensity);\n	vec3 color = mix(mix(transmittance, scatterColor, lightScatter), reflection, clamp(fresnel, 0.0, 1.0));\n\n	color += specular;\n\n	#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n		gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n	#endif\n\n	#ifdef USE_FOG\n\n		#ifdef USE_LOGDEPTHBUF_EXT\n\n			float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n		#else\n\n			float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n		#endif\n\n		#ifdef FOG_EXP2\n\n			float fogFactor = whiteCompliment(exp2(-fogDensity * fogDensity * depth * depth * LOG2));\n\n		#else\n\n			float fogFactor = smoothstep(fogNear, fogFar, depth);\n\n		#endif\n\n		color = mix(color, fogColor, fogFactor);\n\n	#endif\n\n	gl_FragColor = vec4(color, 1.0);\n\n}\n",low:"#ifdef USE_FOG\n\n	#define LOG2 1.442695\n	#define saturate(a) clamp(a, 0.0, 1.0)\n	#define whiteCompliment(a) (1.0 - saturate(a))\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n\n	#endif\n\n#endif\n\n#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n\nuniform float time;\nuniform float timeScale;\n\nuniform sampler2D reflectionMap;\nuniform sampler2D refractionMap;\nuniform sampler2D normalMap;\n\nuniform float waveScale;\nuniform vec2 bigWaves;\nuniform vec2 midWaves;\nuniform vec2 smallWaves;\nuniform float waveChoppiness;\n\nuniform float windSpeed;\nuniform vec2 windDirection;\n\nuniform float waterDensity;\nuniform float chromaticAberration;\nuniform float waterBump;\nuniform float reflectionBump;\nuniform float refractionBump;\nuniform float eta;\n\nuniform vec4 waterColor;\nuniform float sunSpecular;\nuniform float scatterAmount;\nuniform vec4 scatterColor;\n\nuniform float fade;\nuniform vec3 luminosity;\n\nvarying vec3 vLightPosition;\nvarying vec4 vFragPosition;\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\n/**\n * Per-pixel tangent space normal mapping.\n * http://www.thetenthplanet.de/archives/1180\n */\n\nmat3 deriveCotangentFrame(vec3 N, vec3 eyePos) {\n\n	// Get edge vectors of the pixel triangle.\n	vec3 dp1 = dFdx(eyePos);\n	vec3 dp2 = dFdy(eyePos);\n	vec2 duv1 = dFdx(vUv);\n	vec2 duv2 = dFdy(vUv);\n \n	// Solve the linear system.\n	vec3 dp2perp = cross(dp2, N);\n	vec3 dp1perp = cross(N, dp1);\n	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n \n	// Construct a scale-invariant frame.\n	float invmax = inversesqrt(max(dot(T, T), dot(B, B)));\n\n	return mat3(T * invmax, B * invmax, N);\n\n}\n\n/**\n * Tangent space transformation.\n */\n\nvec3 applyTangentSpace(mat3 tbn, vec3 normal) {\n\n	normal.z = sqrt(1.0 - dot(normal.xy, normal.xy)); // Normalmap 2channel.\n	normal.y = -normal.y; // Make normalmap green channel point up.\n\n	//return normalize(normal.x * tbn[0] + normal.y * tbn[1] + normal.z * tbn[2]);\n	return normalize(tbn * normal);\n\n}\n\nvoid main() {\n\n	vec2 fragCoord = (vFragPosition.xy / vFragPosition.w) * 0.5 + 0.5;\n	fragCoord = clamp(fragCoord, 0.002, 0.998);\n\n	// Normal map.\n	float t = time * timeScale;\n	vec2 nCoord = vec2(0.0);\n\n	nCoord = vUv * (waveScale * 0.15) + windDirection.xy * time * (windSpeed * 0.1);\n	vec3 normal0 = 2.0 * texture2D(normalMap, nCoord + vec2(-time * 0.02, -time * 0.03)).rgb - 1.0;\n	nCoord = vUv * (waveScale * 0.5) + windDirection.xy * time * (windSpeed * 0.2) - normal0.xy * waveChoppiness;\n	vec3 normal1 = 2.0 * texture2D(normalMap, nCoord + vec2(time * 0.03, time * 0.02)).rgb - 1.0;\n\n	nCoord = vUv * (waveScale * 1.5) + windDirection.xy * time * (windSpeed * 0.5) - normal1.xy * waveChoppiness;\n	vec3 normal2 = 2.0 * texture2D(normalMap, nCoord + vec2(-time * 0.03, time * 0.04)).rgb - 1.0;\n	nCoord = vUv * (waveScale * 4.0) + windDirection.xy * time * (windSpeed * 0.7) - normal2.xy * waveChoppiness;\n	vec3 normal3 = 2.0 * texture2D(normalMap, nCoord + vec2(time * 0.04, -time * 0.02)).rgb - 1.0;\n\n	vec3 viewDirection = normalize(vViewPosition);\n	vec3 lightDirection = normalize(vLightPosition);\n\n	vec3 surfaceNormal = vNormal;\n\n	#ifdef DOUBLE_SIDED\n\n		float facing = -1.0 + 2.0 * float(gl_FrontFacing);\n		surfaceNormal *= facing;\n		//lightDirection.y *= facing;\n\n	#endif\n\n	mat3 tbn = deriveCotangentFrame(surfaceNormal, vViewPosition);\n\n	vec3 waveNormal = normalize(normal0 * midWaves.x + normal1 * midWaves.y +\n		normal2 * bigWaves.x + normal3 * bigWaves.y);\n\n	waveNormal = applyTangentSpace(tbn, waveNormal * waterBump);\n\n	// Normal for light scattering.\n	vec3 lightNormal = applyTangentSpace(tbn, normalize(normal0 * midWaves.x + normal1 * midWaves.y) * waterBump);\n\n	vec3 lR = reflect(lightDirection, lightNormal);\n	float s = max(dot(lR, viewDirection), 0.0);\n	vec3 lightScatter = max(dot(-lightDirection, lightNormal) * 0.8 + 0.2, 0.0) * vec3(0.1, 0.9, 0.9) * scatterAmount * s;\n\n	// Fresnel term.\n	float R0 = pow((1.0 - eta) / (1.0 + eta), 2.0); \n	float cosine = abs(dot(-viewDirection, waveNormal)); \n	float fresnel = R0 + (1.0 - R0) * pow(1.0 - cosine, 5.0); \n\n	// Texture edge bleed removal.\n	vec2 distortFade = vec2(0.0);\n	distortFade.s = clamp(fragCoord.s * fade, 0.0, 1.0);\n	distortFade.s -= clamp(1.0 - (1.0 - fragCoord.s) * fade, 0.0, 1.0);\n	distortFade.t = clamp(fragCoord.t * fade, 0.0, 1.0);\n	distortFade.t -= clamp(1.0 - (1.0 - fragCoord.t) * fade, 0.0, 1.0); \n	\n	vec3 reflection = texture2D(reflectionMap, fragCoord + (waveNormal.st * reflectionBump * distortFade)).rgb;\n\n	vec3 luminosity = vec3(0.30, 0.59, 0.11);\n	float reflectivity = pow(dot(luminosity, reflection.rgb * 2.0), 3.0);\n\n	vec3 R = reflect(viewDirection, waveNormal);\n\n	float specular = pow(max(dot(R, lightDirection), 0.0), sunSpecular) * reflectivity * 0.25;\n\n	vec2 rCoord = reflect(viewDirection, waveNormal).st;\n	vec3 refraction = vec3(0.0);\n\n	refraction.r = texture2D(refractionMap, (fragCoord - (waveNormal.st * refractionBump * distortFade)) * 1.0).r;\n	refraction.g = texture2D(refractionMap, (fragCoord - (waveNormal.st * refractionBump * distortFade)) * 1.0 - (rCoord * chromaticAberration)).g;\n	refraction.b = texture2D(refractionMap, (fragCoord - (waveNormal.st * refractionBump * distortFade)) * 1.0 - (rCoord * chromaticAberration * 2.0)).b;\n\n	float waterDepth = 5.0;\n	vec3 waterExt = 1.0 - vec3(0.7, 0.85, 0.88);\n\n	vec3 absorbance = waterExt * -waterDepth;\n	vec3 transmittance = refraction * exp(absorbance);\n\n	vec3 color = mix(transmittance + lightScatter, reflection, clamp(fresnel, 0.0, 1.0));\n\n	color += specular;\n\n	#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n		gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n	#endif\n\n	#ifdef USE_FOG\n\n		#ifdef USE_LOGDEPTHBUF_EXT\n\n			float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n		#else\n\n			float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n		#endif\n\n		#ifdef FOG_EXP2\n\n			float fogFactor = whiteCompliment(exp2(-fogDensity * fogDensity * depth * depth * LOG2));\n\n		#else\n\n			float fogFactor = smoothstep(fogNear, fogFar, depth);\n\n		#endif\n\n		color = mix(color, fogColor, fogFactor);\n\n	#endif\n\n	gl_FragColor = vec4(color, 1.0);\n\n}\n"},vertex:"#define EPSILON 1e-6\n\n#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n\nuniform vec3 lightPosition;\nuniform vec4 offsetRepeat;\n\nvarying vec3 vLightDirection;\nvarying vec3 vViewPosition;\nvarying vec4 vFragPosition;\nvarying mat3 vTbn;\nvarying vec2 vUv;\n\nattribute vec4 tangent;\n\nvoid main() {\n\n	vec3 transformedNormal = normalize(normalMatrix * normal);\n	vec3 transformedTangent = normalize(normalMatrix * tangent.xyz);\n\n	vTbn = mat3(\n		transformedTangent,\n		normalize(cross(transformedNormal, transformedTangent) * tangent.w),\n		transformedNormal\n	);\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n	mat3 m3 = mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n	vec3 worldPosition = m3 * position;\n	vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n	vec4 lightVector = viewMatrix * vec4(lightPosition, 1.0);\n\n	vLightDirection = normalize(lightVector.xyz - cameraPosition);\n	vViewPosition = mvPosition.xyz;\n	vFragPosition = projectionMatrix * mvPosition;\n\n	gl_Position = vFragPosition;\n\n	#ifdef USE_LOGDEPTHBUF\n\n		gl_Position.z = log2(max(EPSILON, gl_Position.w + 1.0)) * logDepthBufFC;\n\n		#ifdef USE_LOGDEPTHBUF_EXT\n\n			vFragDepth = 1.0 + gl_Position.w;\n\n		#else\n\n			gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n		#endif\n\n	#endif\n\n}\n"};c.prototype=Object.create(b.ShaderMaterial.prototype),c.prototype.constructor=c;var s={fragment:"#ifdef USE_FOG\n\n	#define LOG2 1.442695\n	#define saturate(a) clamp(a, 0.0, 1.0)\n	#define whiteCompliment(a) (1.0 - saturate(a))\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n\n	#endif\n\n#endif\n\n#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n\nuniform float time;\nuniform float timeScale;\n\nuniform float smoothness;\nuniform float fallAccel;\nuniform float spread;\nuniform float drops;\nuniform float shape;\nuniform float power;\nuniform float alpha;\nuniform float height;\nuniform float overflow;\nuniform vec2 scale;\nuniform vec2 strength;\nuniform vec3 tint;\n\nvarying vec2 vUv;\n\nconst float K1 = 0.366025404; // (sqrt(3) - 1) / 2\nconst float K2 = 0.211324865; // (3 - sqrt(3)) / 6\n\nvec2 hash(vec2 p) {\n\n	p = vec2(\n		dot(p, vec2(127.1, 311.7)),\n		dot(p, vec2(269.5, 183.3))\n	);\n\n	return -1.0 + 2.0 * fract(sin(p * smoothness) * 43758.5453123);\n\n}\n\nfloat noise(vec2 p) {\n\n	vec2 i = floor(p + (p.x + p.y) * K1);\n\n	vec2 a = p - i + (i.x + i.y) * K2;\n	float z = clamp(ceil(a.x - a.y), 0.0, 1.0); // x > y = 1, else 0\n	vec2 o = vec2(z, 1.0 - z);\n	vec2 b = a - o + K2;\n	vec2 c = a - 1.0 + 2.0 * K2;\n\n	vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n\n	vec3 n = h * h * h * h * vec3(\n		dot(a, hash(i)),\n		dot(b, hash(i + o)),\n		dot(c, hash(i + 1.0))\n	);\n\n	return dot(n, vec3(70.0));\n\n}\n\nfloat fbm(vec2 uv) {\n\n	mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\n	float f = 0.5000 * noise(uv);\n	uv = m * uv; f += 0.2500 * noise(uv);\n	uv = m * uv; f += 0.1250 * noise(uv);\n	uv = m * uv; f += 0.0625 * noise(uv);\n\n	return spread + 0.5 * f;\n\n}\n\nvoid main() {\n\n	vec2 q = -vec2(vUv);\n\n	float t = time * timeScale;\n\n	q.x *= scale.x;\n	q.y *= scale.y;\n\n	float T3 = max(3.0, 1.25 * strength.x) * t * 0.6 + pow(abs(q.y), fallAccel) * 2.0;\n\n	float n = fbm(vec2(strength.x * q.x, strength.x * q.y) - vec2(0.0, T3));\n\n	float T3B = max(3.0, 1.25 * strength.y) * t * 0.6 + pow(abs(q.y), fallAccel) * 2.0;\n\n	n = n * 0.5 + (n * 0.5) / (0.001 + 1.5 * fbm(vec2(strength.y * q.x, strength.y * q.y) - vec2(0.0, T3B)));\n\n	float intensity = abs(sin(t * overflow));\n	n *= 1.0 + pow(intensity, 8.0) * 0.5;\n\n	float c = 1.0 - (drops / abs(pow(q.y, 1.0) * 4.0 + 1.0)) * pow(max(0.0, length(q * vec2(1.8 + q.y * 1.5, 0.75)) - n * max(0.0, q.y + 0.25)), shape);\n	float c1 = n * c * ((power + pow(intensity, height) * 0.9 - pow(intensity, 4.0) * 0.4) - pow(vUv.y, 2.0));\n\n	c1 = c1 * 1.05 + sin(c1 * 3.4) * 0.4;\n	c1 *= 0.95 - pow(q.y, 2.0);\n	c1 = clamp(c1, 0.4, 1.0);\n\n	float c4 = c1 * c1 * c1 * c1;\n\n	vec3 color = vec3(\n		(1.0 + tint.r) * c4,\n		(1.0 + tint.g) * c4,\n		(1.0 + tint.b) * c4 / c1\n	);\n\n	float a = c * (1.0 - pow(abs(vUv.y), alpha));\n\n	#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n		gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n	#endif\n\n	#ifdef USE_FOG\n\n		#ifdef USE_LOGDEPTHBUF_EXT\n\n			float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n		#else\n\n			float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n		#endif\n\n		#ifdef FOG_EXP2\n\n			float fogFactor = whiteCompliment(exp2(-fogDensity * fogDensity * depth * depth * LOG2));\n\n		#else\n\n			float fogFactor = smoothstep(fogNear, fogFar, depth);\n\n		#endif\n\n		color = mix(color, fogColor, fogFactor);\n\n	#endif\n\n	gl_FragColor = vec4(color, a);\n\n}\n",vertex:"#define EPSILON 1e-6\n\n#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n\nuniform vec4 offsetRepeat;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n	#ifdef USE_LOGDEPTHBUF\n\n		gl_Position.z = log2(max(EPSILON, gl_Position.w + 1.0)) * logDepthBufFC;\n\n		#ifdef USE_LOGDEPTHBUF_EXT\n\n			vFragDepth = 1.0 + gl_Position.w;\n\n		#else\n\n			gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n		#endif\n\n	#endif\n\n}\n"};d.prototype=Object.create(b.ShaderMaterial.prototype),d.prototype.constructor=d;var t={fragment:"#ifdef USE_FOG\n\n	#define LOG2 1.442695\n	#define saturate(a) clamp(a, 0.0, 1.0)\n	#define whiteCompliment(a) (1.0 - saturate(a))\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n\n	#endif\n\n#endif\n\n#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n\nuniform float time;\nuniform float timeScale;\n\nuniform float primarySpeed;\nuniform float secondarySpeed;\nuniform float displacement;\nuniform float advection;\nuniform float intensity;\n\nuniform vec2 octaveScale;\nuniform vec3 lavaColor;\nuniform sampler2D noiseMap;\n\n//varying float vViewTheta;\nvarying vec2 vUv;\n\nfloat hash21(vec2 n) {\n\n	return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n\n}\n\nmat2 makem2(float theta) {\n\n	float c = cos(theta);\n	float s = sin(theta);\n\n	//float a = mix(c, s, vViewTheta);\n	//float b = mix(s, c, vViewTheta);\n\n	return mat2(c, -s, s, c);\n	//return mat2(a, -b, b, a);\n\n}\n\nfloat noise(vec2 x) {\n\n	return texture2D(noiseMap, x * 0.01).x;\n\n}\n\nvec2 gradn(vec2 p) {\n\n	float ep = 0.09;\n	float gradx = noise(vec2(p.x + ep, p.y)) - noise(vec2(p.x - ep, p.y));\n	float grady = noise(vec2(p.x, p.y + ep)) - noise(vec2(p.x, p.y - ep));\n\n	return vec2(gradx, grady);\n\n}\n\nfloat flow(vec2 p) {\n\n	float t = time * timeScale;\n	float z = 2.0;\n	float rz = 0.0;\n	vec2 bp = p;\n\n	for(float i = 1.0; i < 7.0; ++i) {\n\n		p += t * primarySpeed;\n		bp += t * secondarySpeed;\n\n		// Displacement field.\n		vec2 gr = gradn(i * p * 0.34 + t * displacement);\n\n		// Rotation of the displacement field.\n		gr *= makem2(t * 6.0 - (0.05 * p.x + 0.03 * p.y) * 40.0);\n\n		// Displace the system.\n		p += gr * 0.5;\n\n		// Add noise octave.\n		rz += (sin(noise(p) * 7.0) * 0.5 + 0.5) / z;\n\n		// Blend.\n		p = mix(bp, p, advection);\n\n		// Intensity scaling.\n		z *= intensity;\n\n		// Octave scaling.\n		p *= octaveScale.x;\n		bp *= octaveScale.y;\n\n	}\n\n	return rz;\n\n}\n\nvoid main() {\n\n	float rz = flow(vUv);\n	\n	vec3 color = lavaColor / rz;\n	color = pow(abs(color), vec3(1.4));\n\n	#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n		gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n	#endif\n\n	#ifdef USE_FOG\n\n		#ifdef USE_LOGDEPTHBUF_EXT\n\n			float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n		#else\n\n			float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n		#endif\n\n		#ifdef FOG_EXP2\n\n			float fogFactor = whiteCompliment(exp2(-fogDensity * fogDensity * depth * depth * LOG2));\n\n		#else\n\n			float fogFactor = smoothstep(fogNear, fogFar, depth);\n\n		#endif\n\n		color = mix(color, fogColor, fogFactor);\n\n	#endif\n\n	gl_FragColor = vec4(color, 1.0);\n\n}\n",vertex:"#define EPSILON 1e-6\n\n#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n\nuniform vec4 offsetRepeat;\n\n//varying float vViewTheta;\nvarying vec2 vUv;\n\n//const vec2 Z = vec2(0.0, 1.0);\n\nvoid main() {\n\n	vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n	//vViewTheta = clamp((normalize(cameraPosition - position).z + 1.0) * 0.5, 0.0, 1.0);\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n	gl_Position = projectionMatrix * mvPosition;\n\n	#ifdef USE_LOGDEPTHBUF\n\n		gl_Position.z = log2(max(EPSILON, gl_Position.w + 1.0)) * logDepthBufFC;\n\n		#ifdef USE_LOGDEPTHBUF_EXT\n\n			vFragDepth = 1.0 + gl_Position.w;\n\n		#else\n\n			gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n		#endif\n\n	#endif\n\n}\n"
};e.prototype=Object.create(b.ShaderMaterial.prototype),e.prototype.constructor=e;var u={fragment:"uniform sampler2D tPerturb;\r\nuniform sampler2D tDiffuse;\r\n\r\nuniform float time;\r\nuniform float resetTimer;\r\n\r\nuniform vec2 rollOffSpeed;\r\nuniform vec2 waveStrength;\r\nuniform vec3 tint;\r\n\r\nvarying vec2 vUv;\r\n\r\nconst float fade = 12.0;\r\n\r\n/*vec2 coordRot(vec2 tc, float angle) {\r\n\r\n	float rotX = ((tc.x * 2.0 - 1.0) * (tWidth / tHeight) * cos(angle)) - ((tc.y * 2.0 - 1.0) * sin(angle));\r\n	float rotY = ((tc.y * 2.0 - 1.0) * cos(angle)) + ((tc.x * 2.0 - 1.0) * (tWidth / tHeight) * sin(angle));\r\n	rotX = ((rotX / (tWidth / tHeight)) * 0.5 + 0.5);\r\n	rotY = rotY * 0.5 + 0.5;\r\n\r\n	return vec2(rotX, rotY);\r\n\r\n}*/\r\n\r\nvoid main() {\r\n\r\n	float n = 0.0;\r\n	float drop = 0.0;\r\n\r\n	float resetTimerFaster = resetTimer * rollOffSpeed.x;\r\n	float resetTimerSlow = resetTimer * rollOffSpeed.y;\r\n\r\n	//n *= clamp(ceil(resetTimer / T_DISSOLVE), 0.0, 1.0);\r\n	//drop *= clamp(ceil(resetTimer / T_DROPLETS), 0.0, 1.0);\r\n	// Translate noise values to [0.0, 1.0].\r\n	//n = n * 0.5 + 0.5;\r\n	//drop = drop * 0.5 + 0.5;\r\n\r\n	vec2 perturbSample;\r\n\r\n	if(resetTimer > 0.0) {\r\n\r\n		perturbSample = texture2D(tPerturb, vUv).rg;\r\n\r\n		if(resetTimer < T_DISSOLVE) {\r\n\r\n			n = perturbSample.r;\r\n\r\n		}\r\n\r\n		if(resetTimer < T_DROPLETS) {\r\n\r\n			drop = perturbSample.g;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	float drops = clamp(smoothstep(resetTimerFaster, 0.5 + resetTimerFaster, n), 0.0, 1.0);\r\n	float droplet = clamp(smoothstep(0.75 + resetTimerSlow, 1.0 + resetTimerSlow, drop), 0.0, 1.0);\r\n\r\n	droplet = pow(clamp(droplet + drops, 0.0, 1.0), 0.1) * 3.0;\r\n\r\n	vec2 droplets = vec2(dFdx(vUv + droplet).r, dFdy(vUv + droplet).g);		\r\n\r\n	vec2 wave = vec2(0.0);\r\n\r\n	vec2 waveCoordR;\r\n	vec2 waveCoordG;\r\n	vec2 waveCoordB;\r\n	vec2 dropCoordR;\r\n	vec2 dropCoordG;	\r\n	vec2 dropCoordB;\r\n\r\n	if(resetTimer < 1.0) {\r\n\r\n		wave.x = sin((vUv.x - vUv.y * 2.0) - time * 1.5) * waveStrength.x;\r\n		wave.x += cos((vUv.y * 4.0 - vUv.x * 6.0) + time * 4.2) * waveStrength.y;\r\n		wave.x += sin((vUv.x * 9.0 + vUv.y * 8.0) + time * 3.5) * waveStrength.x;\r\n\r\n		wave.y = sin((vUv.x * 2.0 + vUv.x * 2.5) + time * 2.5) * waveStrength.x;\r\n		wave.y += cos((vUv.y * 3.0 + vUv.x * 6.0) - time * 2.5) * waveStrength.y;\r\n		wave.y += sin((vUv.x * 11.0 - vUv.y * 12.0) + time * 4.5) * waveStrength.x;\r\n\r\n	}\r\n\r\n	//wave *= clamp(ceil(1.0 - resetTimer), 0.0, 1.0);\r\n\r\n	// Texture edge bleed removal.\r\n	vec2 distortFade = vec2(0.0);\r\n	distortFade.s = clamp(vUv.s * fade, 0.0, 1.0);\r\n	distortFade.s -= clamp(1.0 - (1.0 - vUv.s) * fade, 0.0, 1.0);\r\n	distortFade.t = clamp(vUv.t * fade, 0.0, 1.0);\r\n	distortFade.t -= clamp(1.0 - (1.0 - vUv.t) * fade, 0.0, 1.0); \r\n\r\n	//vec2 rotCoordsR = coordRot(vUv, angle?);\r\n\r\n	float dfade = 1.0 - pow(1.0 - distortFade.s * distortFade.t, 2.0);\r\n	wave = wave * dfade;\r\n	droplets = droplets * dfade;\r\n\r\n	waveCoordR = vUv - wave * 0.004;\r\n	waveCoordG = vUv - wave * 0.006;	\r\n	waveCoordB = vUv - wave * 0.008;\r\n\r\n	dropCoordR = vUv - droplets * 1.1;\r\n	dropCoordG = vUv - droplets * 1.2;	\r\n	dropCoordB = vUv - droplets * 1.3;	\r\n\r\n	vec3 dropletColor = vec3(0.0);	\r\n	dropletColor.r = texture2D(tDiffuse, dropCoordR).r;\r\n	dropletColor.g = texture2D(tDiffuse, dropCoordG).g;\r\n	dropletColor.b = texture2D(tDiffuse, dropCoordB).b;\r\n\r\n	vec3 waveColor = vec3(0.0);\r\n	waveColor.r = texture2D(tDiffuse, waveCoordR).r;\r\n	waveColor.g = texture2D(tDiffuse, waveCoordG).g;\r\n	waveColor.b = texture2D(tDiffuse, waveCoordB).b;\r\n\r\n	float dropFade = clamp(resetTimer * 10.0, 0.0, 1.0);\r\n	float dropletMask = smoothstep(0.77 + resetTimerSlow, 0.79 + resetTimerSlow, drop);\r\n	float mask = smoothstep(0.02 + resetTimerFaster, 0.03 + resetTimerFaster, n);\r\n\r\n	vec4 c = texture2D(tDiffuse, vUv);\r\n\r\n	vec3 color = mix(waveColor, c.rgb, dropFade);\r\n	color = mix(color, dropletColor * tint, clamp(dropletMask + mask, 0.0, 1.0) * dropFade);\r\n\r\n	gl_FragColor = vec4(color, c.a);\r\n\r\n}\r\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};f.prototype=Object.create(b.ShaderMaterial.prototype),f.prototype.constructor=f;var v={fragment:"uniform float tWidth;\r\nuniform float tHeight;\r\n\r\nuniform float time;\r\nuniform float randomTime;\r\n\r\nvarying vec2 vUv;\r\n\r\nconst float permTexUnit = 1.0 / 256.0;\r\nconst float permTexUnitHalf = 0.5 / 256.0;\r\n\r\nvec3 randRGB(vec2 tc) {\r\n\r\n	float noise = sin(dot(tc, vec2(12.9898, 78.233))) * 43758.5453;\r\n\r\n	return vec3(\r\n		fract(noise) * 2.0 - 1.0,\r\n		fract(noise * 1.2154) * 2.0 - 1.0,\r\n		fract(noise * 1.3453) * 2.0 - 1.0\r\n	);\r\n\r\n}\r\n\r\nfloat randA(vec2 tc) {\r\n\r\n	return fract(sin(dot(tc, vec2(12.9898, 78.233))) * 43758.5453 * 1.3647) * 2.0 - 1.0;\r\n\r\n}\r\n\r\nfloat fade(float t) {\r\n\r\n	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\r\n\r\n}\r\n\r\nfloat perlinNoise(vec3 p) {\r\n\r\n	// Integer part, scaled so +1 moves permTexUnit texel.\r\n	// Add 1/2 texel to sample texel centers.\r\n	vec3 pi = permTexUnit * floor(p) + permTexUnitHalf;\r\n\r\n	// Fractional part for interpolation.\r\n	vec3 pf = fract(p);\r\n\r\n	// Noise contributions from (x=0, y=0), z=0 and z=1.\r\n	float perm00 = randA(pi.xy);\r\n	vec3  grad000 = randRGB(vec2(perm00, pi.z)) * 4.0 - 1.0;\r\n	float n000 = dot(grad000, pf);\r\n	vec3  grad001 = randRGB(vec2(perm00, pi.z + permTexUnit)) * 4.0 - 1.0;\r\n	float n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));\r\n\r\n	// Noise contributions from (x=0, y=1), z=0 and z=1.\r\n	float perm01 = randA(pi.xy + vec2(0.0, permTexUnit));\r\n	vec3  grad010 = randRGB(vec2(perm01, pi.z)) * 4.0 - 1.0;\r\n	float n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));\r\n	vec3  grad011 = randRGB(vec2(perm01, pi.z + permTexUnit)) * 4.0 - 1.0;\r\n	float n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));\r\n\r\n	// Noise contributions from (x=1, y=0), z=0 and z=1.\r\n	float perm10 = randA(pi.xy + vec2(permTexUnit, 0.0));\r\n	vec3  grad100 = randRGB(vec2(perm10, pi.z)) * 4.0 - 1.0;\r\n	float n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));\r\n	vec3  grad101 = randRGB(vec2(perm10, pi.z + permTexUnit)) * 4.0 - 1.0;\r\n	float n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));\r\n\r\n	// Noise contributions from (x=1, y=1), z=0 and z=1.\r\n	float perm11 = randA(pi.xy + vec2(permTexUnit));\r\n	vec3  grad110 = randRGB(vec2(perm11, pi.z)) * 4.0 - 1.0;\r\n	float n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));\r\n	vec3  grad111 = randRGB(vec2(perm11, pi.z + permTexUnit)) * 4.0 - 1.0;\r\n	float n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));\r\n\r\n	// Blend contributions along x.\r\n	vec4 nX = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));\r\n\r\n	// Blend contributions along y.\r\n	vec2 nXY = mix(nX.xy, nX.zw, fade(pf.y));\r\n\r\n	// Blend contributions along z and return the final noise value.\r\n	return mix(nXY.x, nXY.y, fade(pf.z));\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n	float r = 0.0;\r\n	float g = 0.0;\r\n\r\n	r += perlinNoise(vec3(vUv * vec2(tWidth / 90.0, tHeight / 200.0) + vec2(0.0, time * 0.6), 1.0 + time * 0.2)) * 0.25;\r\n	r += perlinNoise(vec3(vUv * vec2(tWidth / 1200.0, tHeight / 1800.0) + vec2(0.0, time * 0.5), 3.0 + time * 0.3)) * 0.75;\r\n\r\n	g += perlinNoise(vec3(vUv * vec2(tWidth / 40.0, tHeight / 60.0), randomTime / 8.0 + time * 0.02)) * 0.2;\r\n	g += perlinNoise(vec3(vUv * vec2(tWidth / 80.0, tHeight / 200.0), randomTime * 2.1 + time * 0.03)) * 0.25;\r\n\r\n	#ifdef HIGH_QUALITY\r\n\r\n		r += perlinNoise(vec3(vUv * vec2(tWidth / 50.0, tHeight / 80.0) + vec2(0.0, time * 0.8), time * 0.2)) * 0.1;\r\n		r += perlinNoise(vec3(vUv * vec2(tWidth / 200.0, tHeight / 400.0) + vec2(0.0, time * 0.4), 2.0 + time * 0.4)) * 0.25;\r\n\r\n		g += perlinNoise(vec3(vUv * vec2(tWidth / 200.0, tHeight / 400.0), randomTime * 0.23 + time * 0.04)) * 0.2;\r\n		g += perlinNoise(vec3(vUv * vec2(tWidth / 800.0, tHeight / 1800.0), randomTime * 1.64 + time * 0.05)) * 0.1;\r\n\r\n	#endif\r\n\r\n	r = r * 0.5 + 0.5;\r\n	g = g * 0.5 + 0.5;\r\n\r\n	gl_FragColor = vec4(r, g, 0.0, 1.0);\r\n\r\n}\r\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};g.prototype=Object.create(b.ShaderMaterial.prototype),g.prototype.constructor=g;var w={fragment:"uniform sampler2D tDiffuse;\nuniform float opacity;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 texel = texture2D(tDiffuse, vUv);\n	gl_FragColor = opacity * texel;\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};h.prototype=Object.create(b.ShaderMaterial.prototype),h.prototype.constructor=h;var x={fragment:"uniform sampler2D texture1;\nuniform sampler2D texture2;\n\nuniform float opacity1;\nuniform float opacity2;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 texel1 = texture2D(texture1, vUv);\n	vec4 texel2 = texture2D(texture2, vUv);\n\n	#ifdef INVERT_TEX1\n\n		texel1.rgb = vec3(1.0) - texel1.rgb;\n\n	#endif\n\n	#ifdef INVERT_TEX2\n\n		texel2.rgb = vec3(1.0) - texel2.rgb;\n\n	#endif\n\n	gl_FragColor = opacity1 * texel1 + opacity2 * texel2;\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};i.prototype=Object.create(b.ShaderMaterial.prototype),i.prototype.constructor=i;var y={fragment:"uniform sampler2D tDiffuse;\nuniform vec2 uImageIncrement;\nuniform float cKernel[KERNEL_SIZE_INT];\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec2 coord = vUv;\n	vec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\n\n	for(int i = 0; i < KERNEL_SIZE_INT; ++i) {\n\n		sum += texture2D(tDiffuse, coord) * cKernel[i];\n		coord += uImageIncrement;\n\n	}\n\n	gl_FragColor = sum;\n\n}\n",vertex:"uniform vec2 uImageIncrement;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv - ((KERNEL_SIZE_FLOAT - 1.0) / 2.0) * uImageIncrement;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};k.prototype=Object.create(b.ShaderMaterial.prototype),k.prototype.constructor=k,k.prototype.buildKernel=function(a){var b,c,d,e,f=25,g=2*Math.ceil(3*a)+1;for(g>f&&(g=f),e=.5*(g-1),c=this.uniforms.cKernel.value,c.length=0,d=0,b=0;g>b;++b)c[b]=j(b-e,a),d+=c[b];for(b=0;g>b;++b)c[b]/=d};var z={fragment:"uniform sampler2D tDiffuse;\nuniform float stepSize;\nuniform float decay;\nuniform float weight;\nuniform float exposure;\nuniform vec3 lightPosition;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec2 texCoord = vUv;\n\n	// Calculate vector from pixel to light source in screen space.\n	vec2 deltaTexCoord = texCoord - lightPosition.st;\n	float distance = length(deltaTexCoord);\n\n	// Step vector (uv space).\n	vec2 step = stepSize * deltaTexCoord / distance;\n\n	// Number of iterations between pixel and sun.\n	int iterations = int(distance / stepSize);\n\n	// Set up illumination decay factor.\n	float illuminationDecay = 1.0;\n\n	// Sample color.\n	vec4 sample;\n\n	// Color accumulator.\n	vec4 color = vec4(0.0);\n\n	// Estimate the probability of occlusion at each pixel by summing samples along a ray to the light source.\n	for(int i = 0; i < NUM_SAMPLES_INT; ++i) {\n\n		// Don't do more than necessary.\n		if(i <= iterations && texCoord.y < 1.0) {\n\n			sample = texture2D(tDiffuse, texCoord);\n\n			// Apply sample attenuation scale/decay factors.\n			sample *= illuminationDecay * weight;\n\n			color += sample;\n\n			// Update exponential decay factor.\n			illuminationDecay *= decay;\n\n		}\n\n		texCoord -= step;\n\n	}\n\n	// Output final color with a further scale control factor.\n	gl_FragColor = (color / NUM_SAMPLES_FLOAT) * exposure;\n\n}\n",vertex:"varying vec2 vUv;\n\nvoid main() {\n\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n}\n"};l.prototype=Object.create(b.ShaderMaterial.prototype),l.prototype.constructor=l,m.prototype.render=function(a,b,c,d){throw new Error("Render method not implemented!")},m.prototype.setSize=function(a,b){},m.prototype.dispose=function(){var a,b,c=Object.keys(this);for(a=c.length-1;a>=0;--a)b=this[c[a]],null!==b&&"function"==typeof b.dispose&&(b.dispose(),this[c[a]]=null)};var A=(new b.Color,.001953125);n.prototype=Object.create(m.prototype),n.prototype.constructor=n,Object.defineProperty(n.prototype,"resolution",{get:function(){return this.renderTargetX.width},set:function(a){"number"==typeof a&&(0>=a&&(a=1),this.renderTargetX.setSize(a,a),this.renderTargetY.setSize(a,a))}}),n.prototype.render=function(a,b,c,d,e){e&&a.context.disable(a.context.STENCIL_TEST),this.quad.material=this.convolutionMaterial,this.convolutionMaterial.uniforms.tDiffuse.value=c,this.convolutionMaterial.uniforms.uImageIncrement.value.copy(this.blurX),a.render(this.scene,this.camera,this.renderTargetX,!0),this.convolutionMaterial.uniforms.tDiffuse.value=this.renderTargetX,this.convolutionMaterial.uniforms.uImageIncrement.value.copy(this.blurY),a.render(this.scene,this.camera,this.renderTargetY,!0),e&&a.context.enable(a.context.STENCIL_TEST),this.renderToScreen?(this.quad.material=this.combineMaterial,this.combineMaterial.uniforms.texture1.value=c,this.combineMaterial.uniforms.texture2.value=this.renderTargetY,a.render(this.scene,this.camera)):(this.quad.material=this.copyMaterial,this.copyMaterial.uniforms.tDiffuse.value=this.renderTargetY,a.render(this.scene,this.camera,c,this.clear))},n.prototype.setSize=function(a,b){0>=a&&(a=1),0>=b&&(b=1),this.blurY.set(0,a/b*A)},o.prototype=Object.create(m.prototype),o.prototype.constructor=o,Object.defineProperty(o.prototype,"intensity",{get:function(){return this.combineMaterial.uniforms.intensity.value},set:function(a){"number"==typeof a&&(this.combineMaterial.uniforms.intensity.value=a)}}),Object.defineProperty(o.prototype,"resolution",{get:function(){return this.renderTargetX.width},set:function(a){"number"==typeof a&&(0>=a&&(a=1),this.renderTargetX.setSize(a,a),this.renderTargetY.setSize(a,a))}}),Object.defineProperty(o.prototype,"rayLength",{get:function(){return this._rayLength},set:function(a){"number"==typeof a&&a>=0&&(this._rayLength=a,this.calculateStepSizes())}}),Object.defineProperty(o.prototype,"samples",{get:function(){return Number.parseInt(this.godRaysMaterial.defines.NUM_SAMPLES_INT)},set:function(a){"number"==typeof a&&a>=1&&(a=Math.floor(a),this.godRaysMaterial.defines.NUM_SAMPLES_FLOAT=a.toFixed(1),this.godRaysMaterial.defines.NUM_SAMPLES_INT=a.toFixed(0)),this.calculateStepSizes()}}),o.prototype.calculateStepSizes=function(){var a=this.samples;this.stepSizes[0]=this.rayLength*Math.pow(a,-1),this.stepSizes[1]=this.rayLength*Math.pow(a,-2),this.stepSizes[2]=this.rayLength*Math.pow(a,-3)};var B=new b.Color;o.prototype.render=function(a,c,d){var e;this.screenLightPosition.copy(this.lightSource.position).project(this.mainCamera),this.screenLightPosition.x=b.Math.clamp(.5*(this.screenLightPosition.x+1),-1,1),this.screenLightPosition.y=b.Math.clamp(.5*(this.screenLightPosition.y+1),-1,1),this.godRaysMaterial.uniforms.exposure.value=this.computeAngularScalar()*this.exposure,this.mainScene.overrideMaterial=this.maskMaterial,B.copy(a.getClearColor()),e=a.getClearAlpha(),a.setClearColor(0,1),a.render(this.mainScene,this.mainCamera,this.renderTargetX,!0),a.setClearColor(B,e),this.mainScene.overrideMaterial=null,this.quad.material=this.godRaysMaterial,this.godRaysMaterial.uniforms.stepSize.value=this.stepSizes[0],this.godRaysMaterial.uniforms.tDiffuse.value=this.renderTargetX,a.render(this.scene,this.camera,this.renderTargetY),this.godRaysMaterial.uniforms.stepSize.value=this.stepSizes[1],this.godRaysMaterial.uniforms.tDiffuse.value=this.renderTargetY,a.render(this.scene,this.camera,this.renderTargetX),this.godRaysMaterial.uniforms.stepSize.value=this.stepSizes[2],this.godRaysMaterial.uniforms.tDiffuse.value=this.renderTargetX,a.render(this.scene,this.camera,this.renderTargetY),this.quad.material=this.combineMaterial,this.combineMaterial.uniforms.texture1.value=d,this.combineMaterial.uniforms.texture2.value=this.renderTargetY,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,c)};var C=.5*Math.PI,D=new b.Vector3(0,0,-1),E=new b.Vector3,F=new b.Vector3;o.prototype.computeAngularScalar=function(){return F.copy(D),E.copy(D.applyMatrix4(this.mainCamera.matrixWorld)),D.copy(F),F.copy(E),E.sub(this.mainCamera.position),F.sub(this.lightSource.position),b.Math.clamp(E.angleTo(F)-C,0,1)},p.prototype=Object.create(m.prototype),p.prototype.constructor=p;var G=1/60;p.prototype.render=function(a){this.mesh.matrixNeedsUpdate&&this.update();var b=this.material.visible;this.material.visible=!1,this.renderReflection&&a.render(this.scene,this.reflectionCamera,this.reflectionTexture,!0),this.renderRefraction&&a.render(this.scene,this.refractionCamera,this.refractionTexture,!0),this.material.visible=b,null!==this.material&&(this.material.uniforms.time.value+=G)};var H=new b.Vector3,I=new b.Vector3,J=new b.Vector4;p.prototype.update=function(){this.mesh.updateMatrixWorld(),this.camera.updateMatrixWorld(),this.worldPosition.setFromMatrixPosition(this.mesh.matrixWorld),this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld),this.rotationMatrix.extractRotation(this.mesh.matrixWorld),this.normal.set(0,0,1),this.normal.applyMatrix4(this.rotationMatrix),H.copy(this.worldPosition).sub(this.cameraWorldPosition),H.reflect(this.normal).negate(),H.add(this.worldPosition),this.rotationMatrix.extractRotation(this.camera.matrixWorld),this.lookAtPosition.set(0,0,-1),this.lookAtPosition.applyMatrix4(this.rotationMatrix),this.lookAtPosition.add(this.cameraWorldPosition),I.copy(this.worldPosition).sub(this.lookAtPosition),I.reflect(this.normal).negate(),I.add(this.worldPosition),this.mesh.up.set(0,-1,0),this.mesh.up.applyMatrix4(this.rotationMatrix),this.mesh.up.reflect(this.normal).negate(),this.reflectionCamera.position.copy(H),this.reflectionCamera.up=this.mesh.up,this.reflectionCamera.lookAt(I),this.reflectionCamera.updateProjectionMatrix(),this.reflectionCamera.updateMatrixWorld(),this.reflectionCamera.matrixWorldInverse.getInverse(this.reflectionCamera.matrixWorld),this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.reflectionCamera.projectionMatrix),this.textureMatrix.multiply(this.reflectionCamera.matrixWorldInverse),this.plane.setFromNormalAndCoplanarPoint(this.normal,this.worldPosition),this.plane.applyMatrix4(this.reflectionCamera.matrixWorldInverse),this.clipPlane.set(this.plane.normal.x,this.plane.normal.y,this.plane.normal.z,this.plane.constant);var a=this.reflectionCamera.projectionMatrix;J.x=(Math.sign(this.clipPlane.x)+a.elements[8])/a.elements[0],J.y=(Math.sign(this.clipPlane.y)+a.elements[9])/a.elements[5],J.z=-1,J.w=(1+a.elements[10])/a.elements[14];var b=this.clipPlane.multiplyScalar(2/this.clipPlane.dot(J));a.elements[2]=b.x,a.elements[6]=b.y,a.elements[10]=b.z+1+this.clipBias,a.elements[14]=b.w},q.prototype=Object.create(m.prototype),q.prototype.constructor=q,Object.defineProperty(q.prototype,"dissolve",{get:function(){return this._dissolve},set:function(a){this._dissolve=a,this._dissolve||(this.distortionMaterial.uniforms.resetTimer.value=0,this.distortionMaterial.uniforms.time.value=1e3*Math.random(),this.noiseMaterial.uniforms.randomTime.value=10*Math.random()-1)}});var K=1/60;q.prototype.render=function(a,b,c){var d=K*this.speed;this.distortionMaterial.uniforms.tDiffuse.value=c,this.distortionMaterial.uniforms.time.value+=d,this.dissolve&&this.distortionMaterial.uniforms.resetTimer.value<=this.dissolutionEnd&&(this.distortionMaterial.uniforms.resetTimer.value+=d,this.renderPerturbationMap(a)),this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,!1)},q.prototype.renderPerturbationMap=function(a){this.quad.material=this.noiseMaterial,this.noiseMaterial.uniforms.time.value=this.distortionMaterial.uniforms.time.value,a.render(this.scene,this.camera,this.renderTargetPerturb,!1),this.quad.material=this.distortionMaterial},q.prototype.setSize=function(a,b){a=Math.floor(a*this.resolutionScale),b=Math.floor(b*this.resolutionScale),0>=a&&(a=1),0>=b&&(b=1),this.noiseMaterial.uniforms.tWidth.value=a,this.noiseMaterial.uniforms.tHeight.value=b,this.renderTargetPerturb.setSize(a,b)},a.WaterMaterial=c,a.WaterfallMaterial=d,a.LavaMaterial=e,a.DistortionMaterial=f,a.NoiseMaterial=g,a.WaterPass=p,a.DistortionPass=q});